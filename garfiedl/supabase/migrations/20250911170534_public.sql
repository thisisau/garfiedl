create type "public"."post_type" as enum ('post', 'repost', 'quote', 'reply');

create table "public"."comics" (
    "created_at" timestamp with time zone not null default now(),
    "created_by" uuid,
    "last_updated" timestamp with time zone default now(),
    "locator" text not null,
    "id" uuid not null default gen_random_uuid()
);


alter table "public"."comics" enable row level security;

create table "public"."follows" (
    "id" bigint generated by default as identity not null,
    "created_at" timestamp with time zone not null default now(),
    "recipient" uuid,
    "creator" uuid
);


alter table "public"."follows" enable row level security;

create table "public"."posts" (
    "id" bigint generated by default as identity not null,
    "created_at" timestamp with time zone not null default now(),
    "body" text not null default ''::text,
    "link" text,
    "comic" text,
    "likes" bigint not null default '0'::bigint,
    "author" uuid default auth.uid(),
    "type" post_type not null default 'post'::post_type,
    "reference" bigint,
    "replies" bigint not null default '0'::bigint
);


alter table "public"."posts" enable row level security;

create table "public"."posts_likes" (
    "id" bigint generated by default as identity not null,
    "created_at" timestamp with time zone not null default now(),
    "post" bigint not null,
    "user" uuid default auth.uid()
);


alter table "public"."posts_likes" enable row level security;

create table "public"."posts_reports" (
    "id" bigint generated by default as identity not null,
    "created_at" timestamp with time zone not null default now(),
    "reference" bigint,
    "submitted_by" uuid default auth.uid(),
    "body" text not null default ''::text
);


alter table "public"."posts_reports" enable row level security;

create table "public"."profiles" (
    "id" uuid not null,
    "display_name" text,
    "posts_banned" boolean not null default false,
    "following_count" bigint not null default '0'::bigint,
    "follower_count" bigint not null default '0'::bigint
);


alter table "public"."profiles" enable row level security;

CREATE UNIQUE INDEX comics_locator_key ON public.comics USING btree (locator);

CREATE UNIQUE INDEX comics_pkey ON public.comics USING btree (id);

CREATE UNIQUE INDEX follows_pkey ON public.follows USING btree (id);

CREATE UNIQUE INDEX posts_likes_pkey ON public.posts_likes USING btree (id);

CREATE UNIQUE INDEX posts_pkey ON public.posts USING btree (id);

CREATE UNIQUE INDEX posts_reports_pkey ON public.posts_reports USING btree (id);

CREATE UNIQUE INDEX profiles_pkey ON public.profiles USING btree (id);

alter table "public"."comics" add constraint "comics_pkey" PRIMARY KEY using index "comics_pkey";

alter table "public"."follows" add constraint "follows_pkey" PRIMARY KEY using index "follows_pkey";

alter table "public"."posts" add constraint "posts_pkey" PRIMARY KEY using index "posts_pkey";

alter table "public"."posts_likes" add constraint "posts_likes_pkey" PRIMARY KEY using index "posts_likes_pkey";

alter table "public"."posts_reports" add constraint "posts_reports_pkey" PRIMARY KEY using index "posts_reports_pkey";

alter table "public"."profiles" add constraint "profiles_pkey" PRIMARY KEY using index "profiles_pkey";

alter table "public"."comics" add constraint "comics_locator_key" UNIQUE using index "comics_locator_key";

alter table "public"."follows" add constraint "follows_creator_fkey" FOREIGN KEY (creator) REFERENCES profiles(id) ON UPDATE CASCADE ON DELETE CASCADE not valid;

alter table "public"."follows" validate constraint "follows_creator_fkey";

alter table "public"."follows" add constraint "follows_recipient_fkey" FOREIGN KEY (recipient) REFERENCES profiles(id) ON UPDATE CASCADE ON DELETE CASCADE not valid;

alter table "public"."follows" validate constraint "follows_recipient_fkey";

alter table "public"."posts" add constraint "posts_author_fkey" FOREIGN KEY (author) REFERENCES profiles(id) ON UPDATE CASCADE ON DELETE SET NULL not valid;

alter table "public"."posts" validate constraint "posts_author_fkey";

alter table "public"."posts" add constraint "posts_comic_fkey" FOREIGN KEY (comic) REFERENCES comics(locator) ON UPDATE CASCADE ON DELETE SET DEFAULT not valid;

alter table "public"."posts" validate constraint "posts_comic_fkey";

alter table "public"."posts" add constraint "posts_likes_check" CHECK ((likes >= 0)) not valid;

alter table "public"."posts" validate constraint "posts_likes_check";

alter table "public"."posts" add constraint "posts_reference_fkey" FOREIGN KEY (reference) REFERENCES posts(id) ON UPDATE CASCADE ON DELETE CASCADE not valid;

alter table "public"."posts" validate constraint "posts_reference_fkey";

alter table "public"."posts" add constraint "posts_replies_check" CHECK ((replies >= 0)) not valid;

alter table "public"."posts" validate constraint "posts_replies_check";

alter table "public"."posts_likes" add constraint "posts_likes_post_fkey" FOREIGN KEY (post) REFERENCES posts(id) ON UPDATE CASCADE ON DELETE CASCADE not valid;

alter table "public"."posts_likes" validate constraint "posts_likes_post_fkey";

alter table "public"."posts_likes" add constraint "posts_likes_user_fkey" FOREIGN KEY ("user") REFERENCES profiles(id) ON UPDATE CASCADE ON DELETE SET DEFAULT not valid;

alter table "public"."posts_likes" validate constraint "posts_likes_user_fkey";

alter table "public"."posts_reports" add constraint "posts_reports_reference_fkey" FOREIGN KEY (reference) REFERENCES posts(id) ON UPDATE CASCADE ON DELETE CASCADE not valid;

alter table "public"."posts_reports" validate constraint "posts_reports_reference_fkey";

alter table "public"."posts_reports" add constraint "posts_reports_submitted_by_fkey" FOREIGN KEY (submitted_by) REFERENCES profiles(id) ON UPDATE CASCADE ON DELETE RESTRICT not valid;

alter table "public"."posts_reports" validate constraint "posts_reports_submitted_by_fkey";

alter table "public"."profiles" add constraint "profiles_followers_check" CHECK ((follower_count >= 0)) not valid;

alter table "public"."profiles" validate constraint "profiles_followers_check";

alter table "public"."profiles" add constraint "profiles_following_check" CHECK ((following_count >= 0)) not valid;

alter table "public"."profiles" validate constraint "profiles_following_check";

alter table "public"."profiles" add constraint "profiles_id_fkey" FOREIGN KEY (id) REFERENCES auth.users(id) ON UPDATE CASCADE ON DELETE CASCADE not valid;

alter table "public"."profiles" validate constraint "profiles_id_fkey";

set check_function_bodies = off;

CREATE OR REPLACE FUNCTION public.change_username(user_id uuid, new_username text)
 RETURNS void
 LANGUAGE plpgsql
 SET search_path TO ''
AS $function$declare
  username_is_bad boolean;
  id_is_good boolean;
 begin
  SELECT public.username_exists(new_username) INTO username_is_bad;

  IF username_is_bad then
   RAISE EXCEPTION SQLSTATE '90109' USING MESSAGE = 'This username is already in use!';
  end IF;

  IF length(new_username) > 16 or length(new_username) < 3 or new_username ~ '[^a-zA-Z0-9_-]|^[-_]|[-_]$|[-_]{2}' then
   RAISE EXCEPTION SQLSTATE '90110' USING MESSAGE = 'Username does not follow the given criteria';
  end IF;

  SELECT EXISTS(SELECT 1 FROM public.profiles WHERE id = user_id) INTO id_is_good;
  IF not id_is_good then
   RAISE EXCEPTION SQLSTATE '90111' using MESSAGE = 'Couldn''t find a user ID.';
  end IF;

  UPDATE public.profiles
  SET display_name = new_username
  WHERE id = user_id;
 end;$function$
;

CREATE OR REPLACE FUNCTION public.count_likes(post_id bigint)
 RETURNS bigint
 LANGUAGE plpgsql
 SET search_path TO ''
AS $function$
begin
  SELECT reltuples::bigint AS estimate
  FROM pg_class
  WHERE oid = 'public.posts_likes'::regclass AND
  posts_likes.post = post_id;
end;
$function$
;

CREATE OR REPLACE FUNCTION public.create_profile_for_new_user()
 RETURNS trigger
 LANGUAGE plpgsql
 SECURITY DEFINER
 SET search_path TO ''
AS $function$
 BEGIN
  INSERT INTO public.profiles (id, display_name)
  VALUES (NEW.id, public.generate_username(NEW.email));
  RETURN NEW;
 END; $function$
;

CREATE OR REPLACE FUNCTION public.decrement_follows()
 RETURNS trigger
 LANGUAGE plpgsql
 SECURITY DEFINER
 SET search_path TO ''
AS $function$
begin
  update public.profiles
  set following_count = following_count - 1
  where OLD.creator = id;
  update public.profiles
  set follower_count = follower_count - 1
  where OLD.recipient = id;
  return OLD;
end;
$function$
;

CREATE OR REPLACE FUNCTION public.decrement_likes()
 RETURNS trigger
 LANGUAGE plpgsql
 SECURITY DEFINER
 SET search_path TO ''
AS $function$
begin
  update public.posts
  set likes = likes - 1
  where OLD.post = id and likes > 0;
  return OLD;
end;
$function$
;

CREATE OR REPLACE FUNCTION public.decrement_replies()
 RETURNS trigger
 LANGUAGE plpgsql
 SECURITY DEFINER
 SET search_path TO ''
AS $function$
begin
  update public.posts
  set replies = replies - 1
  where OLD.reference = id and replies > 0;
  return OLD;
end;
$function$
;

create or replace view "public"."followed_posts" as  SELECT posts.id,
    posts.created_at,
    posts.body,
    posts.link,
    posts.comic,
    posts.likes,
    posts.author,
    posts.type,
    posts.reference,
    posts.replies
   FROM posts
  WHERE ((posts.type = ANY (ARRAY['post'::post_type, 'repost'::post_type, 'quote'::post_type])) AND (EXISTS ( SELECT 1
           FROM follows
          WHERE ((follows.recipient = posts.author) AND (follows.creator = auth.uid())))))
  ORDER BY posts.created_at DESC;


CREATE OR REPLACE FUNCTION public.generate_username(email text)
 RETURNS text
 LANGUAGE plpgsql
 SET search_path TO ''
AS $function$

DECLARE
 username_new text;
 username_length int := 10;
 username_exists boolean;
BEGIN
 username_new = lower(regexp_replace(split_part(email, '@', 1), '[^a-zA-Z0-9]+', '', 'g'));
 username_new = substr(username_new, 1, username_length);

 SELECT EXISTS(SELECT 1 FROM public.profiles WHERE display_name = username_new) INTO username_exists;

 WHILE username_exists LOOP
  username_new = substr(username_new, 1, username_length) || to_char(trunc(random()*1000000), 'FM000000');
  SELECT EXISTS(SELECT 1 FROM public.profiles WHERE display_name = username_new) INTO username_exists;
 END LOOP;

 RETURN username_new;
END;
$function$
;

CREATE OR REPLACE FUNCTION public.get_followed_posts(page_number integer)
 RETURNS record
 LANGUAGE sql
 SET search_path TO ''
AS $function$
  select * from public.posts
  where type in ('post', 'repost', 'quote') and
    exists (
      select 1 from public.follows where recipient = posts.author and creator = auth.uid()
    )
  order by created_at desc
  limit 5 offset page_number * 5;
$function$
;

CREATE OR REPLACE FUNCTION public.get_user_info(user_id uuid)
 RETURNS json
 LANGUAGE sql
 SECURITY DEFINER
 SET search_path TO ''
AS $function$
  select coalesce(
    (
      select json_build_object(
    'id', id,
    'display_name', display_name
  ) FROM public.profiles where id = user_id
    ),
    json_build_object(
      'id', user_id,
      'display_name', 'Unknown User'
    )
  )
$function$
;

CREATE OR REPLACE FUNCTION public.get_user_info(username text)
 RETURNS record
 LANGUAGE sql
 SECURITY DEFINER
 SET search_path TO ''
AS $function$
  select id, following_count, follower_count from public.profiles where display_name = username
$function$
;

CREATE OR REPLACE FUNCTION public.increment_follows()
 RETURNS trigger
 LANGUAGE plpgsql
 SECURITY DEFINER
 SET search_path TO ''
AS $function$
begin
  update public.profiles
  set following_count = following_count + 1
  where NEW.creator = id;
  update public.profiles
  set follower_count = follower_count + 1
  where NEW.recipient = id;
  return NEW;
end;
$function$
;

CREATE OR REPLACE FUNCTION public.increment_likes()
 RETURNS trigger
 LANGUAGE plpgsql
 SECURITY DEFINER
 SET search_path TO ''
AS $function$
begin
  update public.posts
  set likes = likes + 1
  where NEW.post = id;
  return NEW;
end;
$function$
;

CREATE OR REPLACE FUNCTION public.increment_replies()
 RETURNS trigger
 LANGUAGE plpgsql
 SECURITY DEFINER
 SET search_path TO ''
AS $function$
begin
  update public.posts
  set replies = replies + 1
  where NEW.reference = id;
  return NEW;
end;
$function$
;

CREATE OR REPLACE FUNCTION public.post_is_liked(post_id bigint)
 RETURNS boolean
 LANGUAGE sql
 SET search_path TO ''
AS $function$
  select EXISTS(SELECT 1 from public.posts_likes WHERE auth.uid() = posts_likes."user" AND posts_likes.post = post_id)
$function$
;

CREATE OR REPLACE FUNCTION public.report_post(post_id bigint, report_body text)
 RETURNS void
 LANGUAGE plpgsql
 SECURITY DEFINER
 SET search_path TO ''
AS $function$
declare
  now_timestamp TIMESTAMP;
  report_cutoff TIMESTAMP;
begin
  now_timestamp := NOW();
  report_cutoff := now_timestamp - INTERVAL '15 minutes';

  IF (
    SELECT COUNT(*)
    FROM public.posts_reports
    WHERE posts_reports.created_at > report_cutoff
    and posts_reports.submitted_by = auth.uid()
  ) >= 10 then
    RAISE EXCEPTION SQLSTATE '90114' using message = 'Please wait a few minutes before submitting another report.';
  end if;

  insert into public.posts_reports (reference, body)
  values (post_id, report_body);
end;
$function$
;

create or replace view "public"."suggested_posts" as  SELECT posts.id,
    posts.created_at,
    posts.body,
    posts.link,
    posts.comic,
    posts.likes,
    posts.author,
    posts.type,
    posts.reference,
    posts.replies,
    (((- EXTRACT(epoch FROM (now() - posts.created_at))) / (60)::numeric) + (power((posts.likes)::numeric, 0.67) * (10)::numeric)) AS relevance
   FROM posts
  WHERE (posts.type = ANY (ARRAY['post'::post_type, 'repost'::post_type, 'quote'::post_type]))
  ORDER BY (((- EXTRACT(epoch FROM (now() - posts.created_at))) / (60)::numeric) + (power((posts.likes)::numeric, 0.67) * (10)::numeric)) DESC;


CREATE OR REPLACE FUNCTION public.upload_comic()
 RETURNS text
 LANGUAGE plpgsql
 SECURITY DEFINER
 SET search_path TO ''
AS $function$
declare
  locator uuid;
begin
  if not auth.role() = 'authenticated' then
    raise exception sqlstate '90112' using message = 'You must be signed in to upload a comic!';
  end if;

  if exists(select 1 from public.profiles where id = auth.uid() and posts_banned = TRUE) then
    raise exception sqlstate '90113' using message = 'You are not allowed to post new comics.';
  end if;

  locator := gen_random_uuid();

  insert into public.comics (created_by, locator)
  values (auth.uid(), locator);

  return locator::text;
end;
$function$
;

CREATE OR REPLACE FUNCTION public.username_exists()
 RETURNS boolean
 LANGUAGE plpgsql
 SECURITY DEFINER
 SET search_path TO ''
AS $function$ BEGIN
return EXISTS(SELECT 1 FROM public.profiles WHERE display_name = username_new); END; $function$
;

CREATE OR REPLACE FUNCTION public.username_exists(username_new text)
 RETURNS boolean
 LANGUAGE plpgsql
 SECURITY DEFINER
 SET search_path TO ''
AS $function$ BEGIN
return EXISTS(SELECT 1 FROM public.profiles WHERE LOWER(display_name) = LOWER(username_new)); END; $function$
;

grant delete on table "public"."comics" to "anon";

grant insert on table "public"."comics" to "anon";

grant references on table "public"."comics" to "anon";

grant select on table "public"."comics" to "anon";

grant trigger on table "public"."comics" to "anon";

grant truncate on table "public"."comics" to "anon";

grant update on table "public"."comics" to "anon";

grant delete on table "public"."comics" to "authenticated";

grant insert on table "public"."comics" to "authenticated";

grant references on table "public"."comics" to "authenticated";

grant select on table "public"."comics" to "authenticated";

grant trigger on table "public"."comics" to "authenticated";

grant truncate on table "public"."comics" to "authenticated";

grant update on table "public"."comics" to "authenticated";

grant delete on table "public"."comics" to "service_role";

grant insert on table "public"."comics" to "service_role";

grant references on table "public"."comics" to "service_role";

grant select on table "public"."comics" to "service_role";

grant trigger on table "public"."comics" to "service_role";

grant truncate on table "public"."comics" to "service_role";

grant update on table "public"."comics" to "service_role";

grant delete on table "public"."follows" to "anon";

grant insert on table "public"."follows" to "anon";

grant references on table "public"."follows" to "anon";

grant select on table "public"."follows" to "anon";

grant trigger on table "public"."follows" to "anon";

grant truncate on table "public"."follows" to "anon";

grant update on table "public"."follows" to "anon";

grant delete on table "public"."follows" to "authenticated";

grant insert on table "public"."follows" to "authenticated";

grant references on table "public"."follows" to "authenticated";

grant select on table "public"."follows" to "authenticated";

grant trigger on table "public"."follows" to "authenticated";

grant truncate on table "public"."follows" to "authenticated";

grant update on table "public"."follows" to "authenticated";

grant delete on table "public"."follows" to "service_role";

grant insert on table "public"."follows" to "service_role";

grant references on table "public"."follows" to "service_role";

grant select on table "public"."follows" to "service_role";

grant trigger on table "public"."follows" to "service_role";

grant truncate on table "public"."follows" to "service_role";

grant update on table "public"."follows" to "service_role";

grant delete on table "public"."posts" to "anon";

grant insert on table "public"."posts" to "anon";

grant references on table "public"."posts" to "anon";

grant select on table "public"."posts" to "anon";

grant trigger on table "public"."posts" to "anon";

grant truncate on table "public"."posts" to "anon";

grant update on table "public"."posts" to "anon";

grant delete on table "public"."posts" to "authenticated";

grant insert on table "public"."posts" to "authenticated";

grant references on table "public"."posts" to "authenticated";

grant select on table "public"."posts" to "authenticated";

grant trigger on table "public"."posts" to "authenticated";

grant truncate on table "public"."posts" to "authenticated";

grant update on table "public"."posts" to "authenticated";

grant delete on table "public"."posts" to "service_role";

grant insert on table "public"."posts" to "service_role";

grant references on table "public"."posts" to "service_role";

grant select on table "public"."posts" to "service_role";

grant trigger on table "public"."posts" to "service_role";

grant truncate on table "public"."posts" to "service_role";

grant update on table "public"."posts" to "service_role";

grant delete on table "public"."posts_likes" to "anon";

grant insert on table "public"."posts_likes" to "anon";

grant references on table "public"."posts_likes" to "anon";

grant select on table "public"."posts_likes" to "anon";

grant trigger on table "public"."posts_likes" to "anon";

grant truncate on table "public"."posts_likes" to "anon";

grant update on table "public"."posts_likes" to "anon";

grant delete on table "public"."posts_likes" to "authenticated";

grant insert on table "public"."posts_likes" to "authenticated";

grant references on table "public"."posts_likes" to "authenticated";

grant select on table "public"."posts_likes" to "authenticated";

grant trigger on table "public"."posts_likes" to "authenticated";

grant truncate on table "public"."posts_likes" to "authenticated";

grant update on table "public"."posts_likes" to "authenticated";

grant delete on table "public"."posts_likes" to "service_role";

grant insert on table "public"."posts_likes" to "service_role";

grant references on table "public"."posts_likes" to "service_role";

grant select on table "public"."posts_likes" to "service_role";

grant trigger on table "public"."posts_likes" to "service_role";

grant truncate on table "public"."posts_likes" to "service_role";

grant update on table "public"."posts_likes" to "service_role";

grant delete on table "public"."posts_reports" to "anon";

grant insert on table "public"."posts_reports" to "anon";

grant references on table "public"."posts_reports" to "anon";

grant select on table "public"."posts_reports" to "anon";

grant trigger on table "public"."posts_reports" to "anon";

grant truncate on table "public"."posts_reports" to "anon";

grant update on table "public"."posts_reports" to "anon";

grant delete on table "public"."posts_reports" to "authenticated";

grant insert on table "public"."posts_reports" to "authenticated";

grant references on table "public"."posts_reports" to "authenticated";

grant select on table "public"."posts_reports" to "authenticated";

grant trigger on table "public"."posts_reports" to "authenticated";

grant truncate on table "public"."posts_reports" to "authenticated";

grant update on table "public"."posts_reports" to "authenticated";

grant delete on table "public"."posts_reports" to "service_role";

grant insert on table "public"."posts_reports" to "service_role";

grant references on table "public"."posts_reports" to "service_role";

grant select on table "public"."posts_reports" to "service_role";

grant trigger on table "public"."posts_reports" to "service_role";

grant truncate on table "public"."posts_reports" to "service_role";

grant update on table "public"."posts_reports" to "service_role";

grant delete on table "public"."profiles" to "anon";

grant insert on table "public"."profiles" to "anon";

grant references on table "public"."profiles" to "anon";

grant select on table "public"."profiles" to "anon";

grant trigger on table "public"."profiles" to "anon";

grant truncate on table "public"."profiles" to "anon";

grant update on table "public"."profiles" to "anon";

grant delete on table "public"."profiles" to "authenticated";

grant insert on table "public"."profiles" to "authenticated";

grant references on table "public"."profiles" to "authenticated";

grant select on table "public"."profiles" to "authenticated";

grant trigger on table "public"."profiles" to "authenticated";

grant truncate on table "public"."profiles" to "authenticated";

grant update on table "public"."profiles" to "authenticated";

grant delete on table "public"."profiles" to "service_role";

grant insert on table "public"."profiles" to "service_role";

grant references on table "public"."profiles" to "service_role";

grant select on table "public"."profiles" to "service_role";

grant trigger on table "public"."profiles" to "service_role";

grant truncate on table "public"."profiles" to "service_role";

grant update on table "public"."profiles" to "service_role";

create policy "Allow user to read own comics"
on "public"."comics"
as permissive
for select
to public
using ((created_by = auth.uid()));


create policy "Allow users to follow others"
on "public"."follows"
as permissive
for insert
to authenticated
with check (((creator = auth.uid()) AND (EXISTS ( SELECT 1
   FROM profiles
  WHERE (profiles.id = follows.recipient))) AND (NOT (EXISTS ( SELECT 1
   FROM follows follows_1
  WHERE ((follows_1.creator = follows.creator) AND (follows_1.recipient = follows.recipient)))))));


create policy "Allow users to see who they have followed"
on "public"."follows"
as permissive
for select
to authenticated
using ((creator = auth.uid()));


create policy "Allow users to unfollow others"
on "public"."follows"
as permissive
for delete
to authenticated
using ((creator = auth.uid()));


create policy "Allow posting"
on "public"."posts"
as permissive
for insert
to public
with check (((auth.role() = 'authenticated'::text) AND (author = auth.uid()) AND (EXISTS ( SELECT 1
   FROM profiles
  WHERE ((profiles.id = auth.uid()) AND (profiles.posts_banned = false))))));


create policy "Allow users to delete their own posts"
on "public"."posts"
as permissive
for delete
to authenticated
using ((author = auth.uid()));


create policy "Allow users to view posts"
on "public"."posts"
as permissive
for select
to public
using (true);


create policy "Allow users to like posts"
on "public"."posts_likes"
as permissive
for insert
to public
with check (((auth.role() = 'authenticated'::text) AND ("user" = auth.uid()) AND (EXISTS ( SELECT 1
   FROM posts
  WHERE (posts.id = posts_likes.post))) AND (NOT (EXISTS ( SELECT 1
   FROM posts_likes posts_likes_1
  WHERE ((posts_likes_1.post = posts_likes.post) AND (posts_likes_1."user" = auth.uid())))))));


create policy "Allow users to unlike posts"
on "public"."posts_likes"
as permissive
for delete
to public
using (((auth.role() = 'authenticated'::text) AND ("user" = auth.uid())));


create policy "Allow users to view own liked posts"
on "public"."posts_likes"
as permissive
for select
to authenticated
using ((auth.uid() = "user"));


create policy "Can only update own profile data"
on "public"."profiles"
as permissive
for update
to public
using ((auth.uid() = id));


create policy "Can only view own profile data"
on "public"."profiles"
as permissive
for select
to public
using ((auth.uid() = id));


CREATE TRIGGER user_follow_trigger AFTER INSERT ON public.follows FOR EACH ROW EXECUTE FUNCTION increment_follows();

CREATE TRIGGER user_unfollow_trigger BEFORE DELETE ON public.follows FOR EACH ROW EXECUTE FUNCTION decrement_follows();

CREATE TRIGGER post_reply_trigger AFTER INSERT ON public.posts FOR EACH ROW WHEN ((new.type = 'reply'::post_type)) EXECUTE FUNCTION increment_replies();

CREATE TRIGGER post_unreply_trigger BEFORE DELETE ON public.posts FOR EACH ROW WHEN ((old.type = 'reply'::post_type)) EXECUTE FUNCTION decrement_replies();

CREATE TRIGGER post_like_trigger AFTER INSERT ON public.posts_likes FOR EACH ROW EXECUTE FUNCTION increment_likes();

CREATE TRIGGER post_unlike_trigger BEFORE DELETE ON public.posts_likes FOR EACH ROW EXECUTE FUNCTION decrement_likes();


